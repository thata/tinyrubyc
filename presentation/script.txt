
# 👷🏗️ Building a "Ruby-like Language" Compiler in Ruby

## RubyでつくるRubyみたいな言語のコンパイラ

「RubyでつくるRubyみたいな言語のコンパイラ」ということで、RubyでRubyみたいな言語のコンパイラを作ったお話と、その中で得た経験やコツについて今日はお話ししようと思います。

---

## ✂️ 自己紹介

まず自己紹介です。
はたけやまたかしと申します。株式会社永和システムマネジメントという会社で、Rubyプログラマとして働いています。
Twitter（現X）ではこちらのアカウントで、主にダジャレをつぶやいています。

---

## 🐫 趣味の低レイヤ活動

趣味で低レイヤプログラミングをしています。

東京大学にCPU実験という授業があります。「自分たちでCPUを設計・自作して、自作CPU向けのコンパイラを作成し、その上でレイトレーシングを動かす」という授業になります。

CPU実験のことを知って、なんだその面白そうな授業は！と思い、自分でもCPUを自作したり、RISC-Vのシミュレータを自作したり、CPU実験で使っているMinCamlというコンパイラを移植したりして遊んでいます。

MinCamlコンパイラの移植を行う中で、移植ではなく1からコンパイラを作ってみたいという気持ちが高まった結果、今日お話しするTinyRubyというコンパイラを作成しました。

---

### 🙂 今日話すこと

今日お話しすることは、
「TinyRubyの紹介」
「MinCamlの移植やTinyRubyの作成を通して得たコンパイラ作成のコツについて」
「コンパイラはじめの一歩」ということで、実際にコンパイラを作成する最初の過程をお見せします。

そして、今日話さないことです。字句解析や構文解析、最適化、型検査などについては、今日はお話はしません。

---

# 🐇 TinyRuby の紹介

さっそく TinyRuby についてご紹介します。こんな感じのRubyみたいなプログラミング言語になります。
こちらは10番目のフィボナッチ数の計算をするTinyRubyのプログラムです。

---

## 🐇🐇 TinyRuby のビルドと実行

こちらは、TinyRubyのプログラムのビルド手順になります。

まず、TinyRubyコンパイラでプログラムをコンパイルしてアセンブリを出力、
gcc にアセンブルとリンクをしてもらって実行ファイルを作成します。

この `libtinyruby.c` というのは、TinyRubyの組み込みライブラリで、プリント関数などがC言語で定義されています。

最後に、作成した実行ファイルを実行すると、10番目のフィボナッチ数が画面に出力されます。

---

# 🤖 TinyRuby と MinRuby

さきほど、「TinyRuby は Ruby みたいな言語」と表現しましたが、もう少し具体的に言うと、TinyRuby は MinRuby のサブセットな言語で、TinyRuby はパーサーとして MinRuby のパーサーをそのまま利用しています。

MinRuby とは、書籍「RubyでつくるRuby」に登場する Ruby のサブセット言語です。この MinRuby のパーサは RubyGems として提供されています。

じゃあ、TinyRuby と MinRuby は何が違うのかと言うと、
・「TinyRuby はデータ型が整数型のみ」
・「Array や Hash をサポートしない」
・「関数の引数が6つまで」
など、いくつかの制限があります。

---

## 🐧 TinyRubyコンパイラのターゲット環境

TinyRubyコンパイラのターゲット環境は、CPUが x86-64 で、OSが Linux となります。
私の手元のパソコンは M1 Mac で x86-64 でも Linux でもないので、Docker で仮想環境を作って開発しています。

---

# 🍟 コンパイラ作成のTIPS

TinyRuby についての紹介はここまでにして、次は、TinyRuby の作成を通して得た、コンパイラ作成時に使えるTIPS、便利情報を紹介します。

1) Cコンパイラが出力するアセンブリコードの活用
2) レジスタとABIを知る
3) インクリメンタルな機能実装

---

# :one: Cコンパイラが出力するアセンブリコードを活用

ひとつ目のTIPSは、アセンブリの書き方に悩んだら、Cコンパイラが出力するアセンブリを確認すると良いです。

私は今回 x86 のアセンブリをはじめて書いたのですが、Cコンパイラの出力するコードを参考にすることで、特につまづくことなく x86 アセンブリを出力するコンパイラを作成することができました。

Cコンパイラが出力するアセンブリを確認する方法は、以下の2つがおすすめです。
1つは、gcc の「ハイフンS」オプションを使う方法
もう1つ、Compiler Explorer というサイトを使う方法です。

---

## 🐃 GCCの `-S` オプション

まずは GCC の「ハイフンS」オプションを使う方法を紹介します。

通常、GCCにC言語のソースコードを渡すと、コンパイルとアセンブリが行われて、実行ファイルが作成されたり、オブジェクトファイルが作成されたりします。

ここで gcc に「ハイフンS」オプションをつけることで、コンパイルだけを行って、コンパイル結果をアセンブリファイルとして出力することができます。

例えば、こんな感じのC言語のソースコードを、「ハイフンS」オプションをつけて実行すると...（次のページ）

---

## 🐃🐃 GCCの `-S` オプション

こんな感じにアセンブリコードが出力されます。

ちなみに、アセンブリの出力形式には「インテル形式」と「AT&T形式」とふたつの流派があります。ここではインテル形式で出力するために「-masm=intel」オプションをつけています。

---

## 　⚡️ Compiler Explorer ( https://godbolt.org/ )

https://godbolt.org/

もう1つの方法は、Compiler Explorer というサイトを使う方法です。

Compiler Explorer は、様々な言語、コンパイラ、CPUのアセンブリや中間形式の出力を確認できるカッコいいサイトです。

Compiler Explorer の画面は2つの領域に分かれていて、左側にはソースプログラムを書くと、右側にそのソースのアセンブリが出力されます。

ソースプログラムのどの部分が、アセンブリコードのどの部分に対応しているかが、色によってわかりやすく表示されるので、アセンブリの理解に役立ちます。

二つの使い分けについてですが、出力したアセンブリをそのまま実行したい場合はGCCから出力したアセンブリを利用して、「Cのこういうコードはアセンブリだとどう書くんだろう？」というのを確認したい場合は Compiler Explorer を使うのがおすすめです。

---

# :two: レジスタとABIを知る

二つめのTIPSは「レジスタとABIを知る」です。

コンパイラが出力するアセンブリを理解するためには、対象となるCPUの「レジスタ構成」と「ABI」を知る必要があります。

---

## 📝 汎用レジスタ一覧

まずレジスタについて説明します。

CPUには「レジスタ」と呼ばれるデータの記憶領域があり、CPUが演算を行う際に利用されたり、一時的なデータの置き場として使用されたりします。

レジスタの構成はCPUごとに異なるため、対象となるCPUのレジスタ構成を理解することは、アセンブリを書くうえで重要になります。

x86-64 では、ここに示す 16 本の 64 ビット汎用レジスタがあります。

汎用レジスタという名前の通り、レジスタの使い道には制限がありませんが、RSPレジスタはスタックポインタとして利用されたり、RAX レジスタは関数の戻り値を返すために使われたりと、ある程度決められた用途があります。

また、これ以外にも浮動小数点数用のレジスタや、フラグレジスタなるものがあったりしますが、ここでは省略します。

---

# 🦐 x86-64 のABI (Application Binary Interface)

次に、ABI についてお話しします。

ABI とは、Application Binary Interface の略で、アセンブリ言語レベルでの関数の呼び出しなどの規約のことです。

---

## 🤧 関数の引数の渡し方
## 🐸 関数の戻り値の返し方


例えば、関数を呼び出す際には、第一引数はRDIレジスタに、第二引数はRSIレジスタに、といったように、決められたレジスタに引数の値を渡します。また、第七引数以降はスタックに引数の値を積みます。

さらに、関数の戻り値はRAXレジスタに返す、ということがABIで決められています。

ABI でこうした規約を定義することで、規約に従ったモジュール間での関数呼び出しやデータの連携ができるようになります。

---

## 🦀 ABI の詳細資料

ABI のより詳細な情報については、こちらの「System V Application Binary Interface AMD64 Supplement」などを参照してください。

また、これは x86-64 上で動作する Linux の ABI なので、他の OS、他の CPU の場合は、対象となる環境の ABI を調べる必要があります。

---

# :three: テスト駆動コンパイラ開発

三つ目のTIPSは「テスト駆動コンパイラ開発」です。

「An Incremental Approach to Compiler Construction」という論文で紹介されている「TDDでコンパイラを開発しよう！」というアプローチです。

植山類さんが書かれた「低レイヤを知りたい人のためのCコンパイラ作成入門」で紹介されていた論文で、「低レイヤを知りたい人のためのCコンパイラ作成入門」はこの論文から着想を得たそうです。

最初は整数リテラルを評価するところからスタートして、四則演算、変数代入、変数参照、と機能をしていきます。

---

<style scoped> section { font-size: 2.0em; } </style>

## :hand: テストスクリプト(test.sh)

```test.sh
# 整数リテラル
assert 4649 'p 4649'

# 四則演算
assert 20 'p 10 + 20 - 30 * 4 / 12'
assert 60 'p 10 + 20 + 30'
assert 40 'p 30 + 20 - 10'
assert 200 'p 10 * 20'
assert 33 'p 99 / 3'

# 複文
assert 4649 '1 + 1; p 4649'

# 変数
assert 10 'a = 10; p a'
assert 30 'a = 10; b = 20; p a + b'
```

<!--
-->

---

<style scoped> section { font-size: 2.0em; } </style>

## 🇮🇹 テスト駆動コンパイラ開発のメリット

* テスト駆動開発の一般的なメリット
  * 即時フィードバック
  * デバッグコストの軽減
  * 必要な機能からひとつずつ実装していくことで「考えすぎ」「やりすぎ」を防ぐ
  * 短いサイクルで達成感を得られるため、モチベーションを維持しやすい
* コンパイラ開発に必要な知識を段階的に習得できる
  * 挫折しづらい

（参考）「保守しやすく変化に強いソフトウェアを支える柱　自動テストとテスト駆動開発⁠⁠、その全体像」 (和田卓人) https://gihyo.jp/article/2024/01/automated-test-and-tdd

---

<!-- _class: lead invert -->

# :walking: コンパイラはじめの一歩

これまで紹介したTIPSを使って、整数を評価して返すだけの TinyRuby コンパイラを作ってみます

---

<!-- _class: lead invert -->

# 🎬 動画スタート

---

# 🍜 まとめ

* コンパイラ作成のTIPSの紹介
  * Cコンパイラが出力するアセンブリコードの活用
  * レジスタとABIを知る
  * インクリメンタルな機能実装
* コンパイラを通して低レイヤの世界にふれてみよう！

